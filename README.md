# Реализация бинарного дерева поиска

Этот проект представляет собой реализацию шаблонной структуры данных "бинарное дерево" на C++. Дерево поддерживает вставку, удаление, поиск элементов и различные методы обхода. Реализация работает с любыми типами данных, поддерживающими операции сравнения.

## Основные возможности

- **Шаблонная реализация**: Работает с любыми сравниваемыми типами данных (int, double, string и др.)
- **Основные операции**:
  - Вставка элементов
  - Удаление элементов
  - Проверка наличия элемента
  - Очистка дерева
- **Методы обхода**:
  - Центрированный обход (левое поддерево - корень - правое поддерево)
  - Обратный центрированный обход (правое поддерево - корень - левое поддерево)
- **Визуализация**: Красивый вывод структуры дерева в консоль
- **Специальные конструкторы**:
  - Инициализация из массива
  - Конструктор копирования
  - Конструктор перемещения

## Примеры использования

### Базовые операции

```cpp
BinaryTree<int> tree;

// Вставка элементов
tree.Insert(10);
tree.Insert(5);
tree.Insert(15);

// Проверка наличия элемента
if (tree.Contains(10)) {
    // Элемент найден
}

// Удаление элемента
tree.Remove(5);

// Получение центрированного обхода
auto traversal = tree.RoundLrootR();

// Вывод структуры дерева
tree.Output();
```

### Инициализация из массива

```cpp
int values[] = {20, 10, 30};
BinaryTree<int> tree(values, 3);
```

### Методы обхода

```cpp
// Центрированный обход (лево-корень-право)
auto inOrder = tree.RoundLrootR();

// Обратный центрированный обход (право-корень-лево)
auto reverseInOrder = tree.RoundRrootL();
```

## Тестирование

Проект включает комплексные тесты с использованием фреймворка Google Test, которые проверяют:

- Конструкторы (по умолчанию, из массива, копирования, перемещения)
- Операции вставки и удаления
- Методы обхода
- Граничные случаи
- Различные типы данных (int, double, string)

Для запуска тестов:
```bash
make test
```

## Детали реализации

- **TreeNode**: Вложенный класс, представляющий узлы дерева
- **Управление памятью**: Автоматическая очистка в деструкторе
- **Балансировка**: Реализовано стандартное бинарное дерево поиска (без автоматической балансировки)

## Требования

- C++11 или новее
- Фреймворк Google Test (для тестирования)

## Возможные улучшения

- Добавление балансировки (AVL или красно-черное дерево)
- Реализация дополнительных методов обхода (прямого, концевого, по уровням)
