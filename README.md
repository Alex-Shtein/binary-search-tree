# Задание №1 (Бинарное дерево поиска)

Реализовать на *С++* шаблонный класс `BinaryTree<typename T>` (двоичное дерево поиска), параметризируемый типом `T` хранимых в нём элементов. Для типа `Т` должна быть определена операция сравнения.

Каждый узел дерева (тип `TreeNode` определить в классе `BinaryTree<typename T>`) должен содержать элемент `_value` типа `T` и два указателя – на левое поддерево (`_left`) и правое поддерево (`_right`) (при необходимости можно добавить третий указатель на родительский узел `_parent`).

В классе `BinaryTree<typename T>` предусмотреть поле `_root` – указатель на корневой узел дерева (для пустого дерева `_root = nullptr`).

Реализовать следующие методы класса `BinaryTree<typename T>`:
1.	Конструктор по умолчанию, создающий пустое дерево.
2.	Конструктор, создающий дерево из элементов (типа `T`) одномерного массива.
3.	Деструктор, освобождающий память, занятую узлами дерева.
4.	Конструктор копирования.
5.	Конструктор переноса (перемещения).
6.	Запретить операторы присваивания с копированием и с переносом (с перемещением).
7.	Метод `bool Empty() const`, возвращающий `true`, если в дереве нет элементов, `false` – в противном случае.
8.	Метод `bool Insert(const T& value)`, вставляющий новый узел с указанным значением value.
9.	Метод `bool Remove(const T& value)`, удаляющий узел (первый встретившийся), содержащий указанное значение `value`.
10.	Метод `bool Contains(const T& value)`, возвращающий `true`, если элемент содержится в дереве, и `false` – в противном случае.
11.	Метод `vector<T> RoundLrootR()`, осуществляющий обход ЛКП узлов дерева (каждый узел посещается только один раз) и возвращающий вектор с обойдёнными элементами.
12.	Метод `vector<T> RoundRrootL()`, осуществляющий обход ПКЛ узлов дерева (каждый узел посещается только один раз) и возвращающий вектор с обойдёнными элементами.
13.	Метод `void Output()`, осуществляющий вывод дерева на экран.

При необходимости реализовать другие методы класса.

> **Пояснение**
>
> Двоичным деревом поиска (BST – binary search tree) называется двоичное дерево, для которого выполняются следующие условия:
> -	для любого узла его левое и правое поддеревья являются двоичными деревьями поиска;
> -	значения, размещённые во всех узлах левого поддерева произвольного узла, меньше значения, размещённого в этом узле;
> -	значения, размещённые во всех узлах правого поддерева произвольного узла, не меньше значения, размещённого в этом узле.


Создать проект **binary-tree** с реализацией функций задания.
Тестирование функций осуществлять с помощью gtest (почитать можно [тут](http://google.github.io/googletest/) и [тут](https://github.com/google/googletest)). Для каждой функции библиотеки необходимо создать один или при необходимости несколько тестов, проверяющих корректность её работы.

Для сдачи проекта использовать структуру в файловой системе:
- binary-tree/Task1/*** – файлы с реализацией пунктов задания (имена файлов давать в соответствии с вариантами);
- binary-tree/Task1.Tests/*** – файлы с тестами пунктов задания (имена файлов давать в соответствии с вариантами).
